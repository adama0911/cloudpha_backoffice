/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { DOCUMENT } from '@angular/common';
import { HttpClient, HttpBackend } from '@angular/common/http';
import { Optional, Inject, RendererFactory2 } from '@angular/core';
import { of as observableOf } from 'rxjs';
import { catchError, map, share, tap } from 'rxjs/operators';
import { getSecondaryColor, withSuffix, isIconDefinition, printErr, printWarn, cloneSVG, withSuffixAndColor, getIconDefinitionFromAbbr, replaceFillColor } from '../utils';
/**
 * @record
 */
export function ReqIconTask() { }
if (false) {
    /** @type {?} */
    ReqIconTask.prototype.ob;
}
export class IconService {
    /**
     * @param {?} _rendererFactory
     * @param {?} _handler
     * @param {?} _document
     */
    constructor(_rendererFactory, _handler, _document) {
        this._rendererFactory = _rendererFactory;
        this._handler = _handler;
        this._document = _document;
        this.defaultTheme = 'outline';
        /**
         * Register icons.
         */
        this._svgDefinitions = new Map();
        /**
         * Register rendered (with color) SVG icons.
         */
        this._svgCachedDefinitions = new Map();
        /**
         * Default color settings.
         */
        this._twoToneColorPalette = {
            primaryColor: '#333333',
            secondaryColor: '#E6E6E6'
        };
        this._assetsSource = '';
        /**
         * To note whether a request to an icon is under processing.
         */
        this._httpQueue = new Map();
        // For SSR.
        this._renderer = this._rendererFactory.createRenderer(null, null);
        if (this._handler) {
            this._http = new HttpClient(this._handler);
        }
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    set twoToneColor({ primaryColor, secondaryColor }) {
        if (primaryColor && typeof primaryColor === 'string' && typeof secondaryColor === 'string' || typeof secondaryColor === 'undefined') {
            this._twoToneColorPalette.primaryColor = primaryColor;
            this._twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
        }
    }
    /**
     * @return {?}
     */
    get twoToneColor() {
        return (/** @type {?} */ (Object.assign({}, this.twoToneColor))); // Make a copy to avoid unexpected changes.
    }
    /**
     * Register IconDefinition provided by Ant Design, parsing AbstractNode to svg string.
     * @param {...?} icons
     * @return {?}
     */
    addIcon(...icons) {
        this._addIconLiteral(...icons);
    }
    /**
     * @param {?} prefix
     * @return {?}
     */
    changeAssetsSource(prefix) {
        this._assetsSource = prefix.endsWith('/') ? prefix : prefix + '/';
    }
    /**
     * Register icon.
     * @param {...?} icons Icons that users want to use in their projects. User defined icons and predefined
     *   icons provided by ant-design should implement IconDefinition both.
     * @return {?}
     */
    _addIconLiteral(...icons) {
        icons.forEach(icon => {
            this._svgDefinitions.set(withSuffix(icon.name, icon.theme), icon);
        });
    }
    /**
     * @param {?} key
     * @return {?}
     */
    _get(key) {
        return this._svgDefinitions.get(key) || null;
    }
    /**
     * Get an static file and return it as a string, create a IconDefinition and cache it or return null.
     * @param {?} url
     * @return {?}
     */
    _getFromRemote(url) {
        if (this._http) {
            /** @type {?} */
            let task = this._httpQueue.get(url);
            /** @type {?} */
            let ob;
            if (task) {
                ob = task.ob;
            }
            else {
                ob = this._createObservableRequest(url);
                task = { ob };
                this._httpQueue.set(url, task);
            }
            return ob;
        }
        else {
            printWarn('You need to import HttpClient module to use dynamic importing');
            return observableOf(null);
        }
    }
    /**
     * @param {?} url
     * @return {?}
     */
    _createObservableRequest(url) {
        /** @type {?} */
        const icon = getIconDefinitionFromAbbr(url);
        return this._http.get(`${this._assetsSource}assets/${icon.theme}/${icon.name}.svg`, { responseType: 'text' }).pipe(share(), // Use `share` so if multi directives request the same icon, HTTP request would only be fired once.
        tap(() => {
            this._httpQueue.delete(url);
        }), map(svgString => {
            icon.icon = svgString;
            this._addIconLiteral(icon);
            return icon;
        }), catchError(() => {
            printErr(`the icon ${url} does not exist in your assets folder`);
            this._httpQueue.delete(url);
            return observableOf(null);
        }));
    }
    /**
     * Icon component would call this method to get a SVG element.
     * This method returns a Observable SVG element because when user wants to get an icon from URL, it would be async,
     * so we provided a unified interface here.
     *
     * TODO: namespace in the future
     * @param {?} icon
     * @param {?=} twoToneColor
     * @return {?}
     */
    getRenderedContent(icon, twoToneColor) {
        /** @type {?} */
        const definitionOrNull = isIconDefinition(icon)
            ? (/** @type {?} */ (icon))
            : this._get((/** @type {?} */ (icon)));
        /** @type {?} */
        const $icon = definitionOrNull ? observableOf(definitionOrNull) : this._getFromRemote((/** @type {?} */ (icon)));
        return $icon.pipe(map(i => {
            if (i) {
                return this._loadSVGFromCacheOrCreateNew(i, twoToneColor);
            }
            else {
                printErr(`the icon ${icon} does not exist or is not registered`);
                return null;
            }
        }));
    }
    /**
     * @param {?} icon
     * @param {?=} twoToneColor
     * @return {?}
     */
    _loadSVGFromCacheOrCreateNew(icon, twoToneColor) {
        /** @type {?} */
        let svg;
        /** @type {?} */
        const pri = twoToneColor || this._twoToneColorPalette.primaryColor;
        /** @type {?} */
        const sec = getSecondaryColor(pri) || this._twoToneColorPalette.secondaryColor;
        /** @type {?} */
        const key = withSuffixAndColor(icon.name, icon.theme, pri, sec);
        /** @type {?} */
        const cached = this._svgCachedDefinitions.get(key);
        // If this icon is used before, there should be a copy in cachedDefinitions, just copy it.
        // Otherwise, generate one from string or SVG element, and cache it.
        if (!cached) {
            svg = this._setSVGAttribute(this._colorizeSVGIcon(typeof icon.icon === 'string'
                ? this._createSVGElementFromString(icon.icon)
                : icon.icon, (icon.theme === 'twotone'), pri, sec));
            this._svgCachedDefinitions.set(key, (/** @type {?} */ (Object.assign({}, icon, { icon: svg }))));
        }
        else {
            svg = cached.icon;
        }
        return cloneSVG(svg);
    }
    /**
     * @param {?} str
     * @return {?}
     */
    _createSVGElementFromString(str) {
        /** @type {?} */
        const colorParsed = replaceFillColor(str);
        /** @type {?} */
        const div = this._document.createElement('div');
        div.innerHTML = colorParsed;
        /** @type {?} */
        const svg = div.querySelector('svg');
        if (!svg) {
            throw Error('<svg> tag not found');
        }
        return svg;
    }
    /**
     * @param {?} svg
     * @return {?}
     */
    _setSVGAttribute(svg) {
        this._renderer.setAttribute(svg, 'width', '1em');
        this._renderer.setAttribute(svg, 'height', '1em');
        return svg;
    }
    /**
     * @param {?} svg
     * @param {?} twotone
     * @param {?} pri
     * @param {?} sec
     * @return {?}
     */
    _colorizeSVGIcon(svg, twotone, pri, sec) {
        if (twotone) {
            /** @type {?} */
            const children = svg.childNodes;
            /** @type {?} */
            const length = children.length;
            for (let i = 0; i < length; i++) {
                /** @type {?} */
                const child = (/** @type {?} */ (children[i]));
                if (child.getAttribute('fill') === 'secondaryColor') {
                    this._renderer.setAttribute(child, 'fill', sec);
                }
                else {
                    this._renderer.setAttribute(child, 'fill', pri);
                }
            }
        }
        this._renderer.setAttribute(svg, 'fill', 'currentColor');
        return svg;
    }
    /**
     * Clear all cached icons.
     * @return {?}
     */
    clear() {
        this._svgDefinitions.clear();
    }
}
IconService.ctorParameters = () => [
    { type: RendererFactory2 },
    { type: HttpBackend, decorators: [{ type: Optional }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
];
if (false) {
    /** @type {?} */
    IconService.prototype.defaultTheme;
    /** @type {?} */
    IconService.prototype._renderer;
    /** @type {?} */
    IconService.prototype._http;
    /**
     * Register icons.
     * @type {?}
     */
    IconService.prototype._svgDefinitions;
    /**
     * Register rendered (with color) SVG icons.
     * @type {?}
     */
    IconService.prototype._svgCachedDefinitions;
    /**
     * Default color settings.
     * @type {?}
     */
    IconService.prototype._twoToneColorPalette;
    /** @type {?} */
    IconService.prototype._assetsSource;
    /**
     * To note whether a request to an icon is under processing.
     * @type {?}
     */
    IconService.prototype._httpQueue;
    /** @type {?} */
    IconService.prototype._rendererFactory;
    /** @type {?} */
    IconService.prototype._handler;
    /** @type {?} */
    IconService.prototype._document;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWNvbi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFudC1kZXNpZ24vaWNvbnMtYW5ndWxhci8iLCJzb3VyY2VzIjpbImNvbXBvbmVudC9pY29uLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMzQyxPQUFPLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQy9ELE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFhLGdCQUFnQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzlFLE9BQU8sRUFBYyxFQUFFLElBQUksWUFBWSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3RELE9BQU8sRUFBRSxVQUFVLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQVE3RCxPQUFPLEVBQ0wsaUJBQWlCLEVBQ2pCLFVBQVUsRUFDVixnQkFBZ0IsRUFDaEIsUUFBUSxFQUNSLFNBQVMsRUFDVCxRQUFRLEVBQ1Isa0JBQWtCLEVBQ2xCLHlCQUF5QixFQUN6QixnQkFBZ0IsRUFDakIsTUFBTSxVQUFVLENBQUM7Ozs7QUFFbEIsaUNBRUM7OztJQURDLHlCQUFzQzs7QUFHeEMsTUFBTTs7Ozs7O0lBME1KLFlBQ1ksZ0JBQWtDLEVBQ3RCLFFBQXFCLEVBQ0gsU0FBYztRQUY1QyxxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO1FBQ3RCLGFBQVEsR0FBUixRQUFRLENBQWE7UUFDSCxjQUFTLEdBQVQsU0FBUyxDQUFLO1FBNU14RCxpQkFBWSxHQUFjLFNBQVMsQ0FBQztRQUtwQzs7V0FFRztRQUNPLG9CQUFlLEdBQUcsSUFBSSxHQUFHLEVBQTBCLENBQUM7UUFFOUQ7O1dBRUc7UUFDTywwQkFBcUIsR0FBRyxJQUFJLEdBQUcsRUFBZ0MsQ0FBQztRQUUxRTs7V0FFRztRQUNPLHlCQUFvQixHQUF3QjtZQUNwRCxZQUFZLEVBQUksU0FBUztZQUN6QixjQUFjLEVBQUUsU0FBUztTQUMxQixDQUFDO1FBRVEsa0JBQWEsR0FBRyxFQUFFLENBQUM7UUFFN0I7O1dBRUc7UUFDTyxlQUFVLEdBQUcsSUFBSSxHQUFHLEVBQXVCLENBQUM7UUFrTHBELFdBQVc7UUFDWCxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ2xFLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ2xCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzdDLENBQUM7SUFDSCxDQUFDOzs7OztJQXJMRCxJQUFJLFlBQVksQ0FBQyxFQUFFLFlBQVksRUFBRSxjQUFjLEVBQTZCO1FBQzFFLEVBQUUsQ0FBQyxDQUFDLFlBQVksSUFBSSxPQUFPLFlBQVksS0FBSyxRQUFRLElBQUksT0FBTyxjQUFjLEtBQUssUUFBUSxJQUFJLE9BQU8sY0FBYyxLQUFLLFdBQVcsQ0FBQyxDQUFDLENBQUM7WUFDcEksSUFBSSxDQUFDLG9CQUFvQixDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7WUFDdEQsSUFBSSxDQUFDLG9CQUFvQixDQUFDLGNBQWMsR0FBRyxjQUFjLElBQUksaUJBQWlCLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDL0YsQ0FBQztJQUNILENBQUM7Ozs7SUFFRCxJQUFJLFlBQVk7UUFDZCxNQUFNLENBQUMscUNBQUssSUFBSSxDQUFDLFlBQVksR0FBeUIsQ0FBQyxDQUFDLDJDQUEyQztJQUNyRyxDQUFDOzs7Ozs7SUFNRCxPQUFPLENBQUMsR0FBRyxLQUF1QjtRQUNoQyxJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUM7SUFDakMsQ0FBQzs7Ozs7SUFFRCxrQkFBa0IsQ0FBQyxNQUFjO1FBQy9CLElBQUksQ0FBQyxhQUFhLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDO0lBQ3BFLENBQUM7Ozs7Ozs7SUFPUyxlQUFlLENBQUMsR0FBRyxLQUF1QjtRQUNsRCxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ25CLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUNwRSxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7Ozs7O0lBRVMsSUFBSSxDQUFDLEdBQVc7UUFDeEIsTUFBTSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQztJQUMvQyxDQUFDOzs7Ozs7SUFLUyxjQUFjLENBQUMsR0FBVztRQUNsQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQzs7Z0JBQ1gsSUFBSSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQzs7Z0JBQy9CLEVBQXFDO1lBQ3pDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7Z0JBQ1QsRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUM7WUFDZixDQUFDO1lBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ04sRUFBRSxHQUFHLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDeEMsSUFBSSxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUM7Z0JBQ2QsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ2pDLENBQUM7WUFDRCxNQUFNLENBQUMsRUFBRSxDQUFDO1FBQ1osQ0FBQztRQUFDLElBQUksQ0FBQyxDQUFDO1lBQ04sU0FBUyxDQUFDLCtEQUErRCxDQUFDLENBQUM7WUFDM0UsTUFBTSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM1QixDQUFDO0lBQ0gsQ0FBQzs7Ozs7SUFFTyx3QkFBd0IsQ0FBQyxHQUFXOztjQUNwQyxJQUFJLEdBQW1CLHlCQUF5QixDQUFDLEdBQUcsQ0FBQztRQUMzRCxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQ25CLEdBQUcsSUFBSSxDQUFDLGFBQWEsVUFBVSxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxJQUFJLE1BQU0sRUFDNUQsRUFBRSxZQUFZLEVBQUUsTUFBTSxFQUFFLENBQ3pCLENBQUMsSUFBSSxDQUNKLEtBQUssRUFBRSxFQUFFLG1HQUFtRztRQUM1RyxHQUFHLENBQUMsR0FBRyxFQUFFO1lBQ1AsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDOUIsQ0FBQyxDQUFDLEVBQ0YsR0FBRyxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQ2QsSUFBSSxDQUFDLElBQUksR0FBRyxTQUFTLENBQUM7WUFDdEIsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUMzQixNQUFNLENBQUMsSUFBSSxDQUFDO1FBQ2QsQ0FBQyxDQUFDLEVBQ0YsVUFBVSxDQUFDLEdBQUcsRUFBRTtZQUNkLFFBQVEsQ0FBQyxZQUFZLEdBQUcsdUNBQXVDLENBQUMsQ0FBQztZQUNqRSxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUM1QixNQUFNLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzVCLENBQUMsQ0FBQyxDQUNILENBQUM7SUFDSixDQUFDOzs7Ozs7Ozs7OztJQVNELGtCQUFrQixDQUFDLElBQTZCLEVBQUUsWUFBcUI7O2NBQy9ELGdCQUFnQixHQUEwQixnQkFBZ0IsQ0FBQyxJQUFJLENBQUM7WUFDcEUsQ0FBQyxDQUFDLG1CQUFBLElBQUksRUFBa0I7WUFDeEIsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsbUJBQUEsSUFBSSxFQUFVLENBQUM7O2NBQ3ZCLEtBQUssR0FBRyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsbUJBQUEsSUFBSSxFQUFVLENBQUM7UUFFckcsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQ2YsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQ04sRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDTixNQUFNLENBQUMsSUFBSSxDQUFDLDRCQUE0QixDQUFDLENBQUMsRUFBRSxZQUFZLENBQUMsQ0FBQztZQUM1RCxDQUFDO1lBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ04sUUFBUSxDQUFDLFlBQVksSUFBSSxzQ0FBc0MsQ0FBQyxDQUFDO2dCQUNqRSxNQUFNLENBQUMsSUFBSSxDQUFDO1lBQ2QsQ0FBQztRQUNILENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDUixDQUFDOzs7Ozs7SUFFUyw0QkFBNEIsQ0FBQyxJQUFvQixFQUFFLFlBQXFCOztZQUM1RSxHQUFlOztjQUNiLEdBQUcsR0FBRyxZQUFZLElBQUksSUFBSSxDQUFDLG9CQUFvQixDQUFDLFlBQVk7O2NBQzVELEdBQUcsR0FBRyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsSUFBSSxJQUFJLENBQUMsb0JBQW9CLENBQUMsY0FBYzs7Y0FDeEUsR0FBRyxHQUFHLGtCQUFrQixDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDOztjQUN6RCxNQUFNLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7UUFFbEQsMEZBQTBGO1FBQzFGLG9FQUFvRTtRQUNwRSxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7WUFDWixHQUFHLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FDL0MsT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLFFBQVE7Z0JBQzNCLENBQUMsQ0FBQyxJQUFJLENBQUMsMkJBQTJCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztnQkFDN0MsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQ1gsQ0FBQyxJQUFJLENBQUMsS0FBSyxLQUFLLFNBQVMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQ3ZDLENBQUMsQ0FBQztZQUNILElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLHFDQUFLLElBQUksSUFBRSxJQUFJLEVBQUUsR0FBRyxLQUEwQixDQUFDLENBQUM7UUFDdEYsQ0FBQztRQUFDLElBQUksQ0FBQyxDQUFDO1lBQ04sR0FBRyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUM7UUFDcEIsQ0FBQztRQUVELE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDdkIsQ0FBQzs7Ozs7SUFFUywyQkFBMkIsQ0FBQyxHQUFXOztjQUN6QyxXQUFXLEdBQUcsZ0JBQWdCLENBQUMsR0FBRyxDQUFDOztjQUNuQyxHQUFHLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDO1FBQy9DLEdBQUcsQ0FBQyxTQUFTLEdBQUcsV0FBVyxDQUFDOztjQUN0QixHQUFHLEdBQWUsR0FBRyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUM7UUFDaEQsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ1QsTUFBTSxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQztRQUNyQyxDQUFDO1FBQ0QsTUFBTSxDQUFDLEdBQUcsQ0FBQztJQUNiLENBQUM7Ozs7O0lBRVMsZ0JBQWdCLENBQUMsR0FBZTtRQUN4QyxJQUFJLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxHQUFHLEVBQUUsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ2pELElBQUksQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDbEQsTUFBTSxDQUFDLEdBQUcsQ0FBQztJQUNiLENBQUM7Ozs7Ozs7O0lBRVMsZ0JBQWdCLENBQUMsR0FBZSxFQUFFLE9BQWdCLEVBQUUsR0FBVyxFQUFFLEdBQVc7UUFDcEYsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQzs7a0JBQ04sUUFBUSxHQUFHLEdBQUcsQ0FBQyxVQUFVOztrQkFDekIsTUFBTSxHQUFHLFFBQVEsQ0FBQyxNQUFNO1lBQzlCLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7O3NCQUMxQixLQUFLLEdBQWdCLG1CQUFBLFFBQVEsQ0FBRSxDQUFDLENBQUUsRUFBZTtnQkFDdkQsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsS0FBSyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUM7b0JBQ3BELElBQUksQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7Z0JBQ2xELENBQUM7Z0JBQUMsSUFBSSxDQUFDLENBQUM7b0JBQ04sSUFBSSxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQztnQkFDbEQsQ0FBQztZQUNILENBQUM7UUFDSCxDQUFDO1FBQ0QsSUFBSSxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsR0FBRyxFQUFFLE1BQU0sRUFBRSxjQUFjLENBQUMsQ0FBQztRQUN6RCxNQUFNLENBQUMsR0FBRyxDQUFDO0lBQ2IsQ0FBQzs7Ozs7SUFLRCxLQUFLO1FBQ0gsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUMvQixDQUFDOzs7WUFsT21DLGdCQUFnQjtZQURqQyxXQUFXLHVCQXVPM0IsUUFBUTs0Q0FDUixRQUFRLFlBQUksTUFBTSxTQUFDLFFBQVE7Ozs7SUE1TTlCLG1DQUFvQzs7SUFFcEMsZ0NBQStCOztJQUMvQiw0QkFBNEI7Ozs7O0lBSzVCLHNDQUE4RDs7Ozs7SUFLOUQsNENBQTBFOzs7OztJQUsxRSwyQ0FHRTs7SUFFRixvQ0FBNkI7Ozs7O0lBSzdCLGlDQUFzRDs7SUE4S3BELHVDQUE0Qzs7SUFDNUMsK0JBQTJDOztJQUMzQyxnQ0FBc0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBIdHRwQ2xpZW50LCBIdHRwQmFja2VuZCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IE9wdGlvbmFsLCBJbmplY3QsIFJlbmRlcmVyMiwgUmVuZGVyZXJGYWN0b3J5MiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YgYXMgb2JzZXJ2YWJsZU9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBjYXRjaEVycm9yLCBtYXAsIHNoYXJlLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge1xuICBJY29uRGVmaW5pdGlvbixcbiAgQ2FjaGVkSWNvbkRlZmluaXRpb24sXG4gIFR3b1RvbmVDb2xvclBhbGV0dGUsXG4gIFR3b1RvbmVDb2xvclBhbGV0dGVTZXR0ZXIsXG4gIFRoZW1lVHlwZVxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge1xuICBnZXRTZWNvbmRhcnlDb2xvcixcbiAgd2l0aFN1ZmZpeCxcbiAgaXNJY29uRGVmaW5pdGlvbixcbiAgcHJpbnRFcnIsXG4gIHByaW50V2FybixcbiAgY2xvbmVTVkcsXG4gIHdpdGhTdWZmaXhBbmRDb2xvcixcbiAgZ2V0SWNvbkRlZmluaXRpb25Gcm9tQWJicixcbiAgcmVwbGFjZUZpbGxDb2xvclxufSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVxSWNvblRhc2sge1xuICBvYjogT2JzZXJ2YWJsZTxJY29uRGVmaW5pdGlvbiB8IG51bGw+O1xufVxuXG5leHBvcnQgY2xhc3MgSWNvblNlcnZpY2Uge1xuICBkZWZhdWx0VGhlbWU6IFRoZW1lVHlwZSA9ICdvdXRsaW5lJztcblxuICBwcm90ZWN0ZWQgX3JlbmRlcmVyOiBSZW5kZXJlcjI7XG4gIHByb3RlY3RlZCBfaHR0cDogSHR0cENsaWVudDtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgaWNvbnMuXG4gICAqL1xuICBwcm90ZWN0ZWQgX3N2Z0RlZmluaXRpb25zID0gbmV3IE1hcDxzdHJpbmcsIEljb25EZWZpbml0aW9uPigpO1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciByZW5kZXJlZCAod2l0aCBjb2xvcikgU1ZHIGljb25zLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9zdmdDYWNoZWREZWZpbml0aW9ucyA9IG5ldyBNYXA8c3RyaW5nLCBDYWNoZWRJY29uRGVmaW5pdGlvbj4oKTtcblxuICAvKipcbiAgICogRGVmYXVsdCBjb2xvciBzZXR0aW5ncy5cbiAgICovXG4gIHByb3RlY3RlZCBfdHdvVG9uZUNvbG9yUGFsZXR0ZTogVHdvVG9uZUNvbG9yUGFsZXR0ZSA9IHtcbiAgICBwcmltYXJ5Q29sb3IgIDogJyMzMzMzMzMnLFxuICAgIHNlY29uZGFyeUNvbG9yOiAnI0U2RTZFNidcbiAgfTtcblxuICBwcm90ZWN0ZWQgX2Fzc2V0c1NvdXJjZSA9ICcnO1xuXG4gIC8qKlxuICAgKiBUbyBub3RlIHdoZXRoZXIgYSByZXF1ZXN0IHRvIGFuIGljb24gaXMgdW5kZXIgcHJvY2Vzc2luZy5cbiAgICovXG4gIHByb3RlY3RlZCBfaHR0cFF1ZXVlID0gbmV3IE1hcDxzdHJpbmcsIFJlcUljb25UYXNrPigpO1xuXG4gIHNldCB0d29Ub25lQ29sb3IoeyBwcmltYXJ5Q29sb3IsIHNlY29uZGFyeUNvbG9yIH06IFR3b1RvbmVDb2xvclBhbGV0dGVTZXR0ZXIpIHtcbiAgICBpZiAocHJpbWFyeUNvbG9yICYmIHR5cGVvZiBwcmltYXJ5Q29sb3IgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBzZWNvbmRhcnlDb2xvciA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHNlY29uZGFyeUNvbG9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5fdHdvVG9uZUNvbG9yUGFsZXR0ZS5wcmltYXJ5Q29sb3IgPSBwcmltYXJ5Q29sb3I7XG4gICAgICB0aGlzLl90d29Ub25lQ29sb3JQYWxldHRlLnNlY29uZGFyeUNvbG9yID0gc2Vjb25kYXJ5Q29sb3IgfHwgZ2V0U2Vjb25kYXJ5Q29sb3IocHJpbWFyeUNvbG9yKTtcbiAgICB9XG4gIH1cblxuICBnZXQgdHdvVG9uZUNvbG9yKCk6IFR3b1RvbmVDb2xvclBhbGV0dGVTZXR0ZXIge1xuICAgIHJldHVybiB7IC4uLnRoaXMudHdvVG9uZUNvbG9yIH0gYXMgVHdvVG9uZUNvbG9yUGFsZXR0ZTsgLy8gTWFrZSBhIGNvcHkgdG8gYXZvaWQgdW5leHBlY3RlZCBjaGFuZ2VzLlxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIEljb25EZWZpbml0aW9uIHByb3ZpZGVkIGJ5IEFudCBEZXNpZ24sIHBhcnNpbmcgQWJzdHJhY3ROb2RlIHRvIHN2ZyBzdHJpbmcuXG4gICAqIEBwYXJhbSBpY29uc1xuICAgKi9cbiAgYWRkSWNvbiguLi5pY29uczogSWNvbkRlZmluaXRpb25bXSk6IHZvaWQge1xuICAgIHRoaXMuX2FkZEljb25MaXRlcmFsKC4uLmljb25zKTtcbiAgfVxuXG4gIGNoYW5nZUFzc2V0c1NvdXJjZShwcmVmaXg6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuX2Fzc2V0c1NvdXJjZSA9IHByZWZpeC5lbmRzV2l0aCgnLycpID8gcHJlZml4IDogcHJlZml4ICsgJy8nO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGljb24uXG4gICAqIEBwYXJhbSBpY29ucyBJY29ucyB0aGF0IHVzZXJzIHdhbnQgdG8gdXNlIGluIHRoZWlyIHByb2plY3RzLiBVc2VyIGRlZmluZWQgaWNvbnMgYW5kIHByZWRlZmluZWRcbiAgICogICBpY29ucyBwcm92aWRlZCBieSBhbnQtZGVzaWduIHNob3VsZCBpbXBsZW1lbnQgSWNvbkRlZmluaXRpb24gYm90aC5cbiAgICovXG4gIHByb3RlY3RlZCBfYWRkSWNvbkxpdGVyYWwoLi4uaWNvbnM6IEljb25EZWZpbml0aW9uW10pOiB2b2lkIHtcbiAgICBpY29ucy5mb3JFYWNoKGljb24gPT4ge1xuICAgICAgdGhpcy5fc3ZnRGVmaW5pdGlvbnMuc2V0KHdpdGhTdWZmaXgoaWNvbi5uYW1lLCBpY29uLnRoZW1lKSwgaWNvbik7XG4gICAgfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2dldChrZXk6IHN0cmluZyk6IEljb25EZWZpbml0aW9uIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuX3N2Z0RlZmluaXRpb25zLmdldChrZXkpIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIHN0YXRpYyBmaWxlIGFuZCByZXR1cm4gaXQgYXMgYSBzdHJpbmcsIGNyZWF0ZSBhIEljb25EZWZpbml0aW9uIGFuZCBjYWNoZSBpdCBvciByZXR1cm4gbnVsbC5cbiAgICovXG4gIHByb3RlY3RlZCBfZ2V0RnJvbVJlbW90ZSh1cmw6IHN0cmluZyk6IE9ic2VydmFibGU8SWNvbkRlZmluaXRpb24gfCBudWxsPiB7XG4gICAgaWYgKHRoaXMuX2h0dHApIHtcbiAgICAgIGxldCB0YXNrID0gdGhpcy5faHR0cFF1ZXVlLmdldCh1cmwpO1xuICAgICAgbGV0IG9iOiBPYnNlcnZhYmxlPEljb25EZWZpbml0aW9uIHwgbnVsbD47XG4gICAgICBpZiAodGFzaykge1xuICAgICAgICBvYiA9IHRhc2sub2I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYiA9IHRoaXMuX2NyZWF0ZU9ic2VydmFibGVSZXF1ZXN0KHVybCk7XG4gICAgICAgIHRhc2sgPSB7IG9iIH07XG4gICAgICAgIHRoaXMuX2h0dHBRdWV1ZS5zZXQodXJsLCB0YXNrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYjtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJpbnRXYXJuKCdZb3UgbmVlZCB0byBpbXBvcnQgSHR0cENsaWVudCBtb2R1bGUgdG8gdXNlIGR5bmFtaWMgaW1wb3J0aW5nJyk7XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZU9mKG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2NyZWF0ZU9ic2VydmFibGVSZXF1ZXN0KHVybDogc3RyaW5nKTogT2JzZXJ2YWJsZTxJY29uRGVmaW5pdGlvbiB8IG51bGw+IHtcbiAgICBjb25zdCBpY29uOiBJY29uRGVmaW5pdGlvbiA9IGdldEljb25EZWZpbml0aW9uRnJvbUFiYnIodXJsKTtcbiAgICByZXR1cm4gdGhpcy5faHR0cC5nZXQoXG4gICAgICBgJHt0aGlzLl9hc3NldHNTb3VyY2V9YXNzZXRzLyR7aWNvbi50aGVtZX0vJHtpY29uLm5hbWV9LnN2Z2AsXG4gICAgICB7IHJlc3BvbnNlVHlwZTogJ3RleHQnIH1cbiAgICApLnBpcGUoXG4gICAgICBzaGFyZSgpLCAvLyBVc2UgYHNoYXJlYCBzbyBpZiBtdWx0aSBkaXJlY3RpdmVzIHJlcXVlc3QgdGhlIHNhbWUgaWNvbiwgSFRUUCByZXF1ZXN0IHdvdWxkIG9ubHkgYmUgZmlyZWQgb25jZS5cbiAgICAgIHRhcCgoKSA9PiB7XG4gICAgICAgIHRoaXMuX2h0dHBRdWV1ZS5kZWxldGUodXJsKTtcbiAgICAgIH0pLFxuICAgICAgbWFwKHN2Z1N0cmluZyA9PiB7XG4gICAgICAgIGljb24uaWNvbiA9IHN2Z1N0cmluZztcbiAgICAgICAgdGhpcy5fYWRkSWNvbkxpdGVyYWwoaWNvbik7XG4gICAgICAgIHJldHVybiBpY29uO1xuICAgICAgfSksXG4gICAgICBjYXRjaEVycm9yKCgpID0+IHtcbiAgICAgICAgcHJpbnRFcnIoYHRoZSBpY29uICR7dXJsfSBkb2VzIG5vdCBleGlzdCBpbiB5b3VyIGFzc2V0cyBmb2xkZXJgKTtcbiAgICAgICAgdGhpcy5faHR0cFF1ZXVlLmRlbGV0ZSh1cmwpO1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZU9mKG51bGwpO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEljb24gY29tcG9uZW50IHdvdWxkIGNhbGwgdGhpcyBtZXRob2QgdG8gZ2V0IGEgU1ZHIGVsZW1lbnQuXG4gICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBPYnNlcnZhYmxlIFNWRyBlbGVtZW50IGJlY2F1c2Ugd2hlbiB1c2VyIHdhbnRzIHRvIGdldCBhbiBpY29uIGZyb20gVVJMLCBpdCB3b3VsZCBiZSBhc3luYyxcbiAgICogc28gd2UgcHJvdmlkZWQgYSB1bmlmaWVkIGludGVyZmFjZSBoZXJlLlxuICAgKlxuICAgKiBUT0RPOiBuYW1lc3BhY2UgaW4gdGhlIGZ1dHVyZVxuICAgKi9cbiAgZ2V0UmVuZGVyZWRDb250ZW50KGljb246IEljb25EZWZpbml0aW9uIHwgc3RyaW5nLCB0d29Ub25lQ29sb3I/OiBzdHJpbmcpOiBPYnNlcnZhYmxlPFNWR0VsZW1lbnQgfCBudWxsPiB7XG4gICAgY29uc3QgZGVmaW5pdGlvbk9yTnVsbDogSWNvbkRlZmluaXRpb24gfCBudWxsID0gaXNJY29uRGVmaW5pdGlvbihpY29uKVxuICAgICAgPyBpY29uIGFzIEljb25EZWZpbml0aW9uXG4gICAgICA6IHRoaXMuX2dldChpY29uIGFzIHN0cmluZyk7XG4gICAgY29uc3QgJGljb24gPSBkZWZpbml0aW9uT3JOdWxsID8gb2JzZXJ2YWJsZU9mKGRlZmluaXRpb25Pck51bGwpIDogdGhpcy5fZ2V0RnJvbVJlbW90ZShpY29uIGFzIHN0cmluZyk7XG5cbiAgICByZXR1cm4gJGljb24ucGlwZShcbiAgICAgIG1hcChpID0+IHtcbiAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbG9hZFNWR0Zyb21DYWNoZU9yQ3JlYXRlTmV3KGksIHR3b1RvbmVDb2xvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJpbnRFcnIoYHRoZSBpY29uICR7aWNvbn0gZG9lcyBub3QgZXhpc3Qgb3IgaXMgbm90IHJlZ2lzdGVyZWRgKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9sb2FkU1ZHRnJvbUNhY2hlT3JDcmVhdGVOZXcoaWNvbjogSWNvbkRlZmluaXRpb24sIHR3b1RvbmVDb2xvcj86IHN0cmluZyk6IFNWR0VsZW1lbnQge1xuICAgIGxldCBzdmc6IFNWR0VsZW1lbnQ7XG4gICAgY29uc3QgcHJpID0gdHdvVG9uZUNvbG9yIHx8IHRoaXMuX3R3b1RvbmVDb2xvclBhbGV0dGUucHJpbWFyeUNvbG9yO1xuICAgIGNvbnN0IHNlYyA9IGdldFNlY29uZGFyeUNvbG9yKHByaSkgfHwgdGhpcy5fdHdvVG9uZUNvbG9yUGFsZXR0ZS5zZWNvbmRhcnlDb2xvcjtcbiAgICBjb25zdCBrZXkgPSB3aXRoU3VmZml4QW5kQ29sb3IoaWNvbi5uYW1lLCBpY29uLnRoZW1lLCBwcmksIHNlYyk7XG4gICAgY29uc3QgY2FjaGVkID0gdGhpcy5fc3ZnQ2FjaGVkRGVmaW5pdGlvbnMuZ2V0KGtleSk7XG5cbiAgICAvLyBJZiB0aGlzIGljb24gaXMgdXNlZCBiZWZvcmUsIHRoZXJlIHNob3VsZCBiZSBhIGNvcHkgaW4gY2FjaGVkRGVmaW5pdGlvbnMsIGp1c3QgY29weSBpdC5cbiAgICAvLyBPdGhlcndpc2UsIGdlbmVyYXRlIG9uZSBmcm9tIHN0cmluZyBvciBTVkcgZWxlbWVudCwgYW5kIGNhY2hlIGl0LlxuICAgIGlmICghY2FjaGVkKSB7XG4gICAgICBzdmcgPSB0aGlzLl9zZXRTVkdBdHRyaWJ1dGUodGhpcy5fY29sb3JpemVTVkdJY29uKFxuICAgICAgICB0eXBlb2YgaWNvbi5pY29uID09PSAnc3RyaW5nJ1xuICAgICAgICAgID8gdGhpcy5fY3JlYXRlU1ZHRWxlbWVudEZyb21TdHJpbmcoaWNvbi5pY29uKVxuICAgICAgICAgIDogaWNvbi5pY29uXG4gICAgICAgICwgKGljb24udGhlbWUgPT09ICd0d290b25lJyksIHByaSwgc2VjXG4gICAgICApKTtcbiAgICAgIHRoaXMuX3N2Z0NhY2hlZERlZmluaXRpb25zLnNldChrZXksIHsgLi4uaWNvbiwgaWNvbjogc3ZnIH0gYXMgQ2FjaGVkSWNvbkRlZmluaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdmcgPSBjYWNoZWQuaWNvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmVTVkcoc3ZnKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfY3JlYXRlU1ZHRWxlbWVudEZyb21TdHJpbmcoc3RyOiBzdHJpbmcpOiBTVkdFbGVtZW50IHtcbiAgICBjb25zdCBjb2xvclBhcnNlZCA9IHJlcGxhY2VGaWxsQ29sb3Ioc3RyKTtcbiAgICBjb25zdCBkaXYgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuaW5uZXJIVE1MID0gY29sb3JQYXJzZWQ7XG4gICAgY29uc3Qgc3ZnOiBTVkdFbGVtZW50ID0gZGl2LnF1ZXJ5U2VsZWN0b3IoJ3N2ZycpO1xuICAgIGlmICghc3ZnKSB7XG4gICAgICB0aHJvdyBFcnJvcignPHN2Zz4gdGFnIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gc3ZnO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9zZXRTVkdBdHRyaWJ1dGUoc3ZnOiBTVkdFbGVtZW50KTogU1ZHRWxlbWVudCB7XG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0QXR0cmlidXRlKHN2ZywgJ3dpZHRoJywgJzFlbScpO1xuICAgIHRoaXMuX3JlbmRlcmVyLnNldEF0dHJpYnV0ZShzdmcsICdoZWlnaHQnLCAnMWVtJyk7XG4gICAgcmV0dXJuIHN2ZztcbiAgfVxuXG4gIHByb3RlY3RlZCBfY29sb3JpemVTVkdJY29uKHN2ZzogU1ZHRWxlbWVudCwgdHdvdG9uZTogYm9vbGVhbiwgcHJpOiBzdHJpbmcsIHNlYzogc3RyaW5nKTogU1ZHRWxlbWVudCB7XG4gICAgaWYgKHR3b3RvbmUpIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gc3ZnLmNoaWxkTm9kZXM7XG4gICAgICBjb25zdCBsZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkOiBIVE1MRWxlbWVudCA9IGNoaWxkcmVuWyBpIF0gYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgIGlmIChjaGlsZC5nZXRBdHRyaWJ1dGUoJ2ZpbGwnKSA9PT0gJ3NlY29uZGFyeUNvbG9yJykge1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEF0dHJpYnV0ZShjaGlsZCwgJ2ZpbGwnLCBzZWMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEF0dHJpYnV0ZShjaGlsZCwgJ2ZpbGwnLCBwcmkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3JlbmRlcmVyLnNldEF0dHJpYnV0ZShzdmcsICdmaWxsJywgJ2N1cnJlbnRDb2xvcicpO1xuICAgIHJldHVybiBzdmc7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgYWxsIGNhY2hlZCBpY29ucy5cbiAgICovXG4gIGNsZWFyKCk6IHZvaWQge1xuICAgIHRoaXMuX3N2Z0RlZmluaXRpb25zLmNsZWFyKCk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgX3JlbmRlcmVyRmFjdG9yeTogUmVuZGVyZXJGYWN0b3J5MixcbiAgICBAT3B0aW9uYWwoKSBwcm90ZWN0ZWQgX2hhbmRsZXI6IEh0dHBCYWNrZW5kLFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoRE9DVU1FTlQpIHByb3RlY3RlZCBfZG9jdW1lbnQ6IGFueVxuICApIHtcbiAgICAvLyBGb3IgU1NSLlxuICAgIHRoaXMuX3JlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXJGYWN0b3J5LmNyZWF0ZVJlbmRlcmVyKG51bGwsIG51bGwpO1xuICAgIGlmICh0aGlzLl9oYW5kbGVyKSB7XG4gICAgICB0aGlzLl9odHRwID0gbmV3IEh0dHBDbGllbnQodGhpcy5faGFuZGxlcik7XG4gICAgfVxuICB9XG59XG4iXX0=